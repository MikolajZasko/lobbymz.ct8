/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/funstions.ts":
/*!**************************!*\
  !*** ./src/funstions.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.functions = void 0;\nconst gameData_1 = __webpack_require__(/*! ./gameData */ \"./src/gameData.ts\");\n// // @ts-ignore\n// gameData.canvasArray.reduce(/* functions not used BUT tsDoc [warning] */);\n// // @ts-ignore\n// gameData.canvasArray.reduceRight(/* functions not used BUT tsDoc [warning] */);\nconst functions = {\n    /**\n     * coordinates that will be loaded from sprite\n     * @param x x of square start on sptite / img\n     * @param y y of square start on sptite / img\n     * @returns resolve promise\n     */\n    loadCurrentImage: (x, y) => __awaiter(void 0, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            const hiddenItem = gameData_1.gameData.hiddenItem;\n            const ctx = hiddenItem.getContext(\"2d\");\n            const img = new Image();\n            img.src = \"sprites.png\";\n            img.onload = function () {\n                ctx.drawImage(this, x, y, 48, 48, 0, 0, 48, 48);\n                resolve(\"done\");\n            };\n        });\n    }),\n    /**\n     *\n     * @param canvasArray an array of canvas that background will be overriten\n     * @param canvasId source image to copy to canvas from array\n     */\n    changeBackgroundImage: (canvasArray, canvasId) => {\n        canvasArray.forEach(canvas => {\n            const hiddenItem = gameData_1.gameData.hiddenItem;\n            const hiddenItemCtx = hiddenItem.getContext(\"2d\");\n            const canvasCtx = canvas.getContext(\"2d\");\n            // clear destination canvas\n            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);\n            // copy the image\n            canvasCtx.drawImage(hiddenItem, 0, 0, canvas.width, canvas.height);\n            // save needed data\n            canvas.dataset.canvasId = canvasId;\n        });\n        // clear selected canvas\n        gameData_1.gameData.clearSelectedCanvas();\n    },\n    /**\n     * based on data from user (like x ,y of canvas that mouse is hovered over) changes visual style of canvas, and adds them to variable in gameData.ts\n     */\n    selectCanvas() {\n        let startId = gameData_1.gameData.startCanvasId;\n        let endId = gameData_1.gameData.endCanvasId;\n        let startSplitted = startId.split(\"c\");\n        let endSplitted = endId.split(\"c\");\n        let startRow = parseInt(startSplitted[0].slice(1));\n        let startCol = parseInt(startSplitted[1]);\n        let endRow = parseInt(endSplitted[0].slice(1));\n        let endCol = parseInt(endSplitted[1]);\n        // flip start / end point if necessary\n        if (endCol < startCol) {\n            let tmp = endCol;\n            endCol = startCol;\n            startCol = tmp;\n        }\n        if (endRow < startRow) {\n            let tmp = endRow;\n            endRow = startRow;\n            startRow = tmp;\n        }\n        // check if we should clear selected canvas\n        if (gameData_1.gameData.ctrlDown == false) {\n            gameData_1.gameData.clearSelectedCanvas();\n        }\n        for (let c = startCol; c <= endCol; c++) {\n            for (let r = startRow; r <= endRow; r++) {\n                const canvas = gameData_1.gameData.visibleRightPanelCanvas[r][c];\n                canvas.classList.add(\"selected\");\n                gameData_1.gameData.selectedCanvas.push(canvas);\n            }\n        }\n    },\n    /**\n     * function that checks if should select next canvas automatically (auto checkbox)\n     * @param canvasArray array of current selected canvas\n     */\n    selectNext(canvasArray) {\n        if (gameData_1.gameData.autoCheckbox && canvasArray.length != 0) {\n            // always look for the last element\n            const lastCanvas = canvasArray[canvasArray.length - 1];\n            let lastId = lastCanvas.id;\n            // id's start from 0!!!\n            let currentRow = parseInt(lastId.split(\"c\")[0].slice(1));\n            let currentCol = parseInt(lastId.split(\"c\")[1]);\n            // add 1 to col\n            currentCol += 1;\n            // if we go over with cols, get 1 row down and colls = 0\n            if (currentCol >= gameData_1.gameData.rightPanelCols) {\n                currentCol = 0;\n                currentRow += 1;\n            }\n            // find next canvas\n            const nextCanvas = gameData_1.gameData.visibleRightPanelCanvas[currentRow][currentCol];\n            // select next canvas\n            gameData_1.gameData.selectedCanvas = [nextCanvas];\n            nextCanvas.classList.add(\"selected\");\n        }\n    },\n    /**\n     * override the contextmenu\n     * @param e event from action like click or contextmenu\n     */\n    contextMenuManager(e) {\n        e.preventDefault();\n        const dialog = document.getElementById(\"constextMenu\");\n        // show / hide save menu dialog\n        if (gameData_1.gameData.contextMenuShown) {\n            // hide\n            dialog.close();\n            dialog.style.display = \"none\";\n        }\n        else {\n            // show\n            dialog.showModal();\n            dialog.style.display = \"flex\";\n        }\n        // change value in gameData\n        gameData_1.gameData.contextMenuShown = !gameData_1.gameData.contextMenuShown;\n    },\n    /**\n     * called when ctrl + s is clicked or function is chosen from contextmenu\n     * saves current state of map to a file\n     */\n    save() {\n        // gather required data\n        let data = [];\n        for (let r = 0; r < gameData_1.gameData.rightPanelRows; r++) {\n            for (let c = 0; c < gameData_1.gameData.rightPanelCols; c++) {\n                const canvas = gameData_1.gameData.visibleRightPanelCanvas[r][c];\n                // check if canvas has any data\n                if (canvas.dataset.canvasId != null && canvas.dataset.canvasId != undefined && canvas.dataset.canvasId != \"undefined\" && canvas.dataset.canvasId != \"null\") {\n                    console.log(\"canvas is NOT empty\");\n                    // save the information\n                    data.push({\n                        rightPositionId: `r${r}c${c}`,\n                        leftPositionId: canvas.dataset.canvasId\n                    });\n                }\n            }\n        }\n        // console.log(data);\n        // JSON\n        const dataJson = JSON.stringify(data);\n        const type = \"application/json\";\n        const filename = \"data.json\";\n        // data, filename, type\n        // console.log(data, data.length);\n        const blob = new Blob([dataJson], { type: type });\n        // console.log(blob);\n        const url = URL.createObjectURL(blob);\n        // console.log(url);\n        const link = document.createElement(\"a\");\n        link.style.display = \"none\";\n        link.innerText = \"save\";\n        link.href = url;\n        link.download = filename;\n        link.click();\n        document.body.appendChild(link);\n        setTimeout(() => {\n            URL.revokeObjectURL(url);\n        }, 0);\n    },\n    /**\n     * called when ctrl + l is clicked or function is chosen from contextmenu\n     * prompts user to select a previously saved file\n     */\n    selectAFileFunc() {\n        console.log(\"fileSelect\");\n        // prompt user for a file\n        const fileSelect = document.getElementById(\"fileSelect\");\n        // console.log(\"fileSelect here : \", fileSelect);\n        fileSelect.click();\n    },\n    /**\n     * creates input type file,\n     * handeles file retrival and calls readFile function\n     */\n    createFileSelect() {\n        // Create an input element\n        const fileSelect = document.createElement('input');\n        fileSelect.type = 'file';\n        // fileSelect.value = \"load\"\n        fileSelect.accept = \"application/json\";\n        fileSelect.id = \"fileSelect\";\n        // Add an event listener to handle the file selection\n        fileSelect.addEventListener('input', (event) => {\n            const target = event.target;\n            const files = target.files;\n            if (files && files.length > 0) {\n                const selectedFile = files[0];\n                console.log('File selected:', selectedFile);\n                // Handle the selected file (e.g., read it, upload it, etc.)\n                this.readFile(selectedFile);\n            }\n            // clear the input velue so it triggers every time you upload ANY file (even the same one)\n            target.value = \"\";\n        });\n        const body = document.getElementById(\"body\");\n        body.append(fileSelect);\n    },\n    /**\n     * reads file using FileReader and calls restoreData function\n     * @param file a file to be read and restored by restoreData function\n     */\n    readFile(file) {\n        const reader = new FileReader();\n        reader.readAsText(file);\n        reader.onload = function () {\n            // restore game state from data\n            functions.restoreData(reader.result);\n        };\n    },\n    /**\n     * checks if json is valid and restores data from a file\n     * @param rederRes reader.result from FileReader from readFile function\n     */\n    restoreData(rederRes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // here we try to get data, if json is invalid throw an error as an alert()\n            let jsonRes;\n            try {\n                jsonRes = JSON.parse(rederRes);\n            }\n            catch (error) {\n                // Handle the error gracefully\n                console.error(\"Error parsing JSON:\", error);\n                jsonRes = false;\n            }\n            if (jsonRes) {\n                console.log(\"we can restore\");\n                if (jsonRes.length > 0) {\n                    // get unique images to load one by one\n                    let uniqueImagesFound = [];\n                    let canvasByImages = {};\n                    jsonRes.forEach((element) => {\n                        let leftPositionId = element.leftPositionId;\n                        let rightPositionId = element.rightPositionId;\n                        if (!uniqueImagesFound.includes(element.leftPositionId)) {\n                            // add to unique\n                            uniqueImagesFound.push(element.leftPositionId);\n                            // add new obj to canvasByImages + value\n                            canvasByImages[leftPositionId] = [rightPositionId];\n                        }\n                        else {\n                            // add rightPositionId to existing canvasToLoad\n                            canvasByImages[leftPositionId].push(rightPositionId);\n                        }\n                    });\n                    // clear all canvas on the right side\n                    for (let r = 0; r < gameData_1.gameData.rightPanelRows; r++) {\n                        for (let c = 0; c < gameData_1.gameData.rightPanelCols; c++) {\n                            const canvas = gameData_1.gameData.visibleRightPanelCanvas[r][c];\n                            // clear background\n                            const context = canvas.getContext('2d');\n                            if (context) {\n                                context.clearRect(0, 0, 48, 48);\n                            }\n                        }\n                    }\n                    // start loading images and placing them on board\n                    for (let i = 0; i < uniqueImagesFound.length; i++) {\n                        const leftCanvasID = uniqueImagesFound[i];\n                        // extract coordinates from id\n                        const LCanvasCoordinates = functions.extractNumbersFromId(leftCanvasID, \"left\");\n                        // copy image\n                        const leftCanvasDOM = gameData_1.gameData.leftPanelCanvas[LCanvasCoordinates[0]][LCanvasCoordinates[1]][LCanvasCoordinates[2]];\n                        const rightCanvasArray = canvasByImages[leftCanvasID];\n                        for (let n = 0; n < rightCanvasArray.length; n++) {\n                            const rightCanvasID = rightCanvasArray[n];\n                            // extract coordinates from id\n                            const RCanvasCoordinates = functions.extractNumbersFromId(rightCanvasID, \"right\");\n                            // copy / draw loaded image\n                            const rightCanvasDOM = gameData_1.gameData.visibleRightPanelCanvas[RCanvasCoordinates[0]][RCanvasCoordinates[1]];\n                            const rightCanvasDOMCtx = rightCanvasDOM.getContext('2d');\n                            rightCanvasDOMCtx.drawImage(leftCanvasDOM, 0, 0);\n                            // save needed data: \n                            rightCanvasDOM.dataset.canvasId = leftCanvasID;\n                        }\n                    }\n                    // free space\n                    canvasByImages = null;\n                    uniqueImagesFound = null;\n                    jsonRes = null;\n                }\n                else {\n                    alert(\"empty json / no array\");\n                }\n            }\n            else {\n                alert(\"damaged / invalid json file\");\n            }\n        });\n    },\n    /**\n     * duplicates all canvases to a hidden rightPanel class\n     * @param cutMode if true, selected canvases after a succesfull paste will be cleared\n     * @returns resolve promise\n     */\n    copy() {\n        return __awaiter(this, arguments, void 0, function* (cutMode = false) {\n            // check if something is already being copied\n            if (!gameData_1.gameData.copyStatus || cutMode) {\n                gameData_1.gameData.copyStatus = true;\n                return new Promise(function (resolve, rejext) {\n                    // copy selected right canvas to a buffer\n                    gameData_1.gameData.copiedCanvas = gameData_1.gameData.selectedCanvas;\n                    // copy all canvas map to hidden right panel\n                    for (let r = 0; r < gameData_1.gameData.rightPanelRows; r++) {\n                        for (let c = 0; c < gameData_1.gameData.rightPanelCols; c++) {\n                            // find both canvas\n                            const shownCanvas = gameData_1.gameData.visibleRightPanelCanvas[r][c];\n                            const hiddenCanvas = gameData_1.gameData.hiddenRightPanelCanvas[r][c];\n                            // pass needed data (for save/load)\n                            hiddenCanvas.dataset.canvasId = shownCanvas.dataset.canvasId;\n                            // copy background\n                            const hiddenCanvasCtx = hiddenCanvas.getContext('2d');\n                            hiddenCanvasCtx.drawImage(shownCanvas, 0, 0);\n                        }\n                    }\n                    // add class \"superSelected\" to copied canvas\n                    gameData_1.gameData.copiedCanvas.forEach((canvas) => {\n                        canvas.classList.add(\"superSelected\");\n                    });\n                    resolve(\"copied\");\n                });\n            }\n            else {\n                gameData_1.gameData.clearSelectedCanvas();\n                alert(\"finish pasting then copy/cut again :D \");\n            }\n        });\n    },\n    /**\n     * sets an Interval on displayPossiblePaste function if something was copied / cut\n     */\n    paste() {\n        console.log(\"paste\");\n        gameData_1.gameData.clearSelectedCanvas();\n        if (gameData_1.gameData.copiedCanvas != null && gameData_1.gameData.copiedCanvas.length != 0 && gameData_1.gameData.copyStatus) {\n            // keep displaying possible outcome\n            gameData_1.gameData.pasteInterval = setInterval(functions.displayPossiblePaste, 50);\n        }\n        else {\n            alert(\"nothing to paste\");\n        }\n    },\n    /**\n     * displays possible paste action result, finished when any canvas on rightPanel is clicked (eventlistener on rightPanel canvas)\n     */\n    displayPossiblePaste() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // iterate through previously chnaged canvas and bring them back\n            if (gameData_1.gameData.previouslyChangedCanvas != null) {\n                for (let i = 0; i < gameData_1.gameData.previouslyChangedCanvas.length; i++) {\n                    const canvas = gameData_1.gameData.previouslyChangedCanvas[i];\n                    // replace for background from second right panel that is hidden\n                    // \n                    // find the adequate canvas in hidden right panel\n                    const canvasCoordinates = functions.extractIdFromCanvas(canvas);\n                    const hiddenRightCanvas = gameData_1.gameData.hiddenRightPanelCanvas[canvasCoordinates[0]][canvasCoordinates[1]];\n                    // un-highlight un-selected elements\n                    // canvas.classList.remove(\"highlightedCanvas\")\n                    // un-pass needed data (for save/load) IF it was there, if not dont add more\n                    if (hiddenRightCanvas.dataset.canvasId != null) {\n                        canvas.dataset.canvasId = hiddenRightCanvas.dataset.canvasId;\n                    }\n                    // replace the background\n                    const canvasCtx = canvas.getContext('2d');\n                    yield canvasCtx.drawImage(hiddenRightCanvas, 0, 0);\n                }\n            }\n            // save canvas that are changed on this iteration / tick\n            let changedCanvas = [];\n            // get current position (canvas that the mouse has hovered on)\n            const mouseOnCanvas = gameData_1.gameData.currentCanvas;\n            let previouslyGeneratedCanvasData = null;\n            for (let i = 0; i < gameData_1.gameData.copiedCanvas.length; i++) {\n                const canvasToCopy = gameData_1.gameData.copiedCanvas[i];\n                if (i == 0) {\n                    // first start from mouse location / copy from first to mouse location\n                    const currentCanvasCtx = mouseOnCanvas.getContext('2d');\n                    currentCanvasCtx.drawImage(canvasToCopy, 0, 0);\n                    // get data from canvas id (rows and colls)\n                    previouslyGeneratedCanvasData = functions.extractIdFromCanvas(mouseOnCanvas);\n                    // pass needed data (for save/load)\n                    mouseOnCanvas.dataset.canvasId = canvasToCopy.dataset.canvasId;\n                    // \n                    changedCanvas.push(mouseOnCanvas);\n                }\n                else {\n                    // the canvas that we now try to generate\n                    let canvasToCopyCoordinates = functions.extractIdFromCanvas(canvasToCopy);\n                    // previous canvas to copy data\n                    let canvasToCopyPreviousCoordinates = functions.extractIdFromCanvas(gameData_1.gameData.copiedCanvas[i - 1]);\n                    // previously generated canvas data\n                    let previusCanvasGenR = previouslyGeneratedCanvasData[0];\n                    let previusCanvasGenC = previouslyGeneratedCanvasData[1];\n                    // calculate the difference between previously copied and the next to be copied\n                    let collDiff = canvasToCopyCoordinates[1] - canvasToCopyPreviousCoordinates[1];\n                    let rowDiff = canvasToCopyCoordinates[0] - canvasToCopyPreviousCoordinates[0];\n                    // find canvas relatively next\n                    let canvasToPasteC = previusCanvasGenC + collDiff;\n                    let canvasToPasteR = previusCanvasGenR + rowDiff;\n                    // check if it is on table / not out of index\n                    if (canvasToPasteC < gameData_1.gameData.rightPanelCols && canvasToPasteR < gameData_1.gameData.rightPanelRows) {\n                        // find the dom element\n                        const canvasToPaste = gameData_1.gameData.visibleRightPanelCanvas[canvasToPasteR][canvasToPasteC];\n                        // highlight selected elements\n                        // canvasToPaste.classList.add(\"highlightedCanvas\")\n                        // copy the image\n                        const canvasToPasteCtx = canvasToPaste.getContext('2d');\n                        canvasToPasteCtx.drawImage(canvasToCopy, 0, 0);\n                        // pass needed data (for save/load)\n                        canvasToPaste.dataset.canvasId = canvasToCopy.dataset.canvasId;\n                        // \n                        changedCanvas.push(canvasToPaste);\n                    }\n                    previouslyGeneratedCanvasData = [canvasToPasteR, canvasToPasteC];\n                }\n            }\n            // after all has been cleared / pasted for new swap previously changed\n            gameData_1.gameData.previouslyChangedCanvas = changedCanvas;\n        });\n    },\n    /**\n     * helper function\n     * @param canvas DOM canvas\n     * @returns row and column of this canvas based on id [rows, columns]\n     */\n    extractIdFromCanvas(canvas) {\n        // take just the numbers from id\n        let canvasId = canvas.id.split(\"c\");\n        let canvasR = parseInt(canvasId[0].slice(1));\n        let canvasC = parseInt(canvasId[1]);\n        return [canvasR, canvasC];\n    },\n    /**\n     * helper function\n     * @param id a string extracted from DOM canvas\n     * @param side can be left or right (left has 3 parms block, row, column, right has 2 rows, columns)\n     * @returns\n     */\n    extractNumbersFromId(id, side) {\n        if (side == \"right\") {\n            // take just the numbers from id\n            let canvasId = id.split(\"c\");\n            let canvasR = parseInt(canvasId[0].slice(1));\n            let canvasC = parseInt(canvasId[1]);\n            return [canvasR, canvasC];\n        }\n        else {\n            // take just the numbers from id\n            let canvasArr1 = id.split(\"c\");\n            let canvasArr2 = canvasArr1[0].split(\"r\");\n            let canvasC = parseInt(canvasArr1[1]);\n            let canvasR = parseInt(canvasArr2[1]);\n            let canvasB = parseInt(canvasArr2[0].slice(1));\n            return [canvasB, canvasR, canvasC];\n        }\n    },\n    /**\n     * called when ctrl + X is clicked or function is chosen from contextmenu\n     * highlights selected canvas and performs cut function in cut mode\n     */\n    cut() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // check if something is already being copied\n            if (!gameData_1.gameData.copyStatus) {\n                gameData_1.gameData.copyStatus = true;\n                console.log(\"cut\");\n                // inform paste action that we are using cut() not copy()\n                gameData_1.gameData.cutAction = true;\n                // \n                // for cut make it take images from hidden panel, then after paste (mousedown)\n                // color them black / dont give them data about background \n                // \n                // copy\n                yield functions.copy(true);\n            }\n            else {\n                gameData_1.gameData.clearSelectedCanvas();\n                alert(\"finish pasting then copy/cut again :D \");\n            }\n        });\n    },\n    /**\n     * after a successfull paste, removes canvas that were selected\n     */\n    finishCut() {\n        console.log(\"finish cut, : \", gameData_1.gameData.copiedCanvas);\n        gameData_1.gameData.copiedCanvas.forEach(canvas => {\n            if (canvas != null) {\n                const canvasCtx = canvas.getContext('2d');\n                // Set the fill color to black\n                canvasCtx.fillStyle = 'black';\n                // Draw a black square that fills the entire canvas (48x48)\n                canvasCtx.fillRect(0, 0, 48, 48);\n                // remove data\n                canvas.dataset.canvasId = null;\n            }\n        });\n    },\n    /**\n     * helper function, removes classes \"selected\" and \"superSelected\" from DOM element\n     * @param canvas HTMLCanvasElement\n     */\n    removeCSSFromSelected(canvas) {\n        // remove class \"selected\" and \"superSelected\" from copied canvas\n        canvas.classList.remove(\"selected\");\n        canvas.classList.remove(\"superSelected\");\n    },\n    /**\n     * a function that after a cuccessfull paste, checks if any canvas that were initially selected, were also in the pasted ones, if so it removes them form gameData.copiedCanvas so that they wont get cleared\n     */\n    pastedInCopied() {\n        let initiallySelectedCanvas = [];\n        // make tmp array of just the id's of elements that will be pasted\n        gameData_1.gameData.previouslyChangedCanvas.forEach((canvas) => {\n            initiallySelectedCanvas.push(canvas.id);\n        });\n        // now compare to initially selected canvas\n        for (let i = 0; i < gameData_1.gameData.copiedCanvas.length; i++) {\n            const canvas = gameData_1.gameData.copiedCanvas[i];\n            if (initiallySelectedCanvas.includes(canvas.id)) {\n                // we have the same canvas that we want to cut and pasted\n                // -> we can't clear this one, should be pasted\n                gameData_1.gameData.copiedCanvas[i] = null;\n                // + we have to remove it's selected classes NOW\n                // \n                // remove the borders from canvas that were selected\n                functions.removeCSSFromSelected(canvas);\n            }\n        }\n    },\n    /**\n     * function that registers an action\n     * each time it is called a new log is added to log array (gameData.rightPanelVisibleLog)\n     * when we undo (ctrl + Z) or redo (ctrl + Y), we use this array to move forwards and backwards in time\n     * by the use of cuurent index (gameData.visibleLogIndex) that is increased after every action\n     */\n    registerAction() {\n        console.log(\"---------------- registerAction ------------------\");\n        // first check if we should remove logs\n        if (gameData_1.gameData.recentlyUndone) {\n            console.log(\"gameData.recentlyUndonegameData.recentlyUndonegameData.recentlyUndonegameData.recentlyUndone\", gameData_1.gameData.visibleLogIndex);\n            gameData_1.gameData.rightPanelVisibleLog.splice(gameData_1.gameData.visibleLogIndex + 1);\n            // gameData.visibleLogIndex -= 1\n            gameData_1.gameData.recentlyUndone = false;\n        }\n        // think about this / fix logs - undo should work fine (test it) !!!\n        if (gameData_1.gameData.recentlyRedone) {\n            console.log(\"before : aaaaaaaaaaaaaaaaaa\", gameData_1.gameData.rightPanelVisibleLog);\n            gameData_1.gameData.rightPanelVisibleLog.splice(gameData_1.gameData.visibleLogIndex + 1);\n            console.log(\"after : aaaaaaaaaaaaaaaaaaa\", gameData_1.gameData.rightPanelVisibleLog);\n            // gameData.visibleLogIndex -= 1\n            gameData_1.gameData.recentlyRedone = false;\n        }\n        setTimeout(() => {\n            // register changes / the whole map's (hidden + shown)\n            // or in other words, make a backup log that we can restore data from\n            // form both log arrays\n            let visibleLog = [];\n            // let hiddenLog = []\n            // access DOM 1M times to get all hidden and visible data\n            for (let r = 0; r < gameData_1.gameData.rightPanelRows; r++) {\n                for (let c = 0; c < gameData_1.gameData.rightPanelCols; c++) {\n                    const visibleCanvas = gameData_1.gameData.visibleRightPanelCanvas[r][c];\n                    visibleLog.push({\n                        data: visibleCanvas.dataset.canvasId,\n                        id: `r${r}c${c}`\n                    });\n                }\n            }\n            // add log to gameData.visibleLogIndex\n            gameData_1.gameData.rightPanelVisibleLog.push(visibleLog);\n            // move log +1 \n            gameData_1.gameData.visibleLogIndex += 1;\n            console.log(gameData_1.gameData.visibleLogIndex);\n            // console.log(\"visibleLog ::::::::::::::::::::: \", visibleLog);\n            // console.log(\"hiddenLog ::::::::::::::::::::: \", hiddenLog);\n            console.log(\"current logging status sssssssssssssssssssssssss : \", gameData_1.gameData.rightPanelVisibleLog);\n        }, 0);\n    },\n    /**\n     * called when ctrl + Z is clicked or function is chosen from contextmenu\n     * goes back in gameData.rightPanelVisibleLog, and restores state of rightPanel\n     * 1 step back\n     */\n    undo() {\n        console.log(\"--- ! undo action ! ---\");\n        // go back in log\n        if (gameData_1.gameData.visibleLogIndex <= 0) {\n            alert(\"nothing to restore\");\n        }\n        else {\n            // lower index\n            gameData_1.gameData.visibleLogIndex -= 1;\n            console.log(\"undo restoring from index : \", gameData_1.gameData.visibleLogIndex);\n            console.log(gameData_1.gameData.rightPanelVisibleLog);\n            // restore all from last index before\n            const logToRestoreFrom = gameData_1.gameData.rightPanelVisibleLog[gameData_1.gameData.visibleLogIndex];\n            // potentially error !!!!!\n            logToRestoreFrom.forEach(object => {\n                // console.log(\"objextus maximus --- : \", object);\n                if (object.data == undefined || object.data == \"undefined\" || object.data == null || object.data == \"null\") {\n                    const destinationCoordinates = functions.extractNumbersFromId(object.id, \"right\");\n                    const destinationCanvas = gameData_1.gameData.visibleRightPanelCanvas[destinationCoordinates[0]][destinationCoordinates[1]];\n                    // !!!!! here, because value can potentially (in theory) be \"undefined\" and undefined\n                    // \n                    // check if value changed \n                    if (object.data != destinationCanvas.dataset.canvasId) {\n                        // clear the canvas\n                        const canvasCtx = destinationCanvas.getContext('2d');\n                        // Set the fill color to black\n                        canvasCtx.fillStyle = 'black';\n                        // Draw a black square that fills the entire canvas (48x48)\n                        canvasCtx.fillRect(0, 0, 48, 48);\n                        // clear canvas data\n                        destinationCanvas.dataset.canvasId = null;\n                    }\n                }\n                else {\n                    const destinationCoordinates = functions.extractNumbersFromId(object.id, \"right\");\n                    const sourceCoordinates = functions.extractNumbersFromId(object.data, \"left\");\n                    // copy image from given id\n                    const destinationCanvas = gameData_1.gameData.visibleRightPanelCanvas[destinationCoordinates[0]][destinationCoordinates[1]];\n                    const sourceCanvas = gameData_1.gameData.leftPanelCanvas[sourceCoordinates[0]][sourceCoordinates[1]][sourceCoordinates[2]];\n                    // !!!!! here, because value can potentially (in theory) be \"undefined\" and undefined\n                    // \n                    // check if value changed \n                    if (sourceCanvas.id != destinationCanvas.dataset.canvasId) {\n                        // copy the image\n                        const destinationCanvasCtx = destinationCanvas.getContext('2d');\n                        destinationCanvasCtx.drawImage(sourceCanvas, 0, 0);\n                        // add canvas data\n                        destinationCanvas.dataset.canvasId = sourceCanvas.id;\n                    }\n                }\n            });\n            // remove now or when some action comes in?\n            gameData_1.gameData.recentlyUndone = true;\n        }\n    },\n    /**\n     * called when ctrl + Y is clicked or function is chosen from contextmenu\n     * goes forwards in gameData.rightPanelVisibleLog (if there is a possibility of that), and restores state of rightPanel\n     * 1 step forwards\n     */\n    redo() {\n        console.log(\"--- ! redo action ! ---\");\n        // go back in log\n        if (gameData_1.gameData.visibleLogIndex == gameData_1.gameData.rightPanelVisibleLog.length - 1) {\n            alert(\"nothing to redo\");\n        }\n        else {\n            // increase index\n            gameData_1.gameData.visibleLogIndex += 1;\n            console.log(\"redo restoring from index : \", gameData_1.gameData.visibleLogIndex);\n            console.log(gameData_1.gameData.rightPanelVisibleLog);\n            // redo all from next index\n            const logToRestoreFrom = gameData_1.gameData.rightPanelVisibleLog[gameData_1.gameData.visibleLogIndex];\n            logToRestoreFrom.forEach(object => {\n                // console.log(\"objextus maximus --- : \", object);\n                if (object.data == undefined || object.data == \"undefined\" || object.data == null || object.data == \"null\") {\n                    const destinationCoordinates = functions.extractNumbersFromId(object.id, \"right\");\n                    const destinationCanvas = gameData_1.gameData.visibleRightPanelCanvas[destinationCoordinates[0]][destinationCoordinates[1]];\n                    // !!!!! here, because value can potentially (in theory) be \"undefined\" and undefined\n                    // \n                    // check if value changed \n                    if (object.data != destinationCanvas.dataset.canvasId) {\n                        // clear the canvas\n                        const canvasCtx = destinationCanvas.getContext('2d');\n                        // Set the fill color to black\n                        canvasCtx.fillStyle = 'black';\n                        // Draw a black square that fills the entire canvas (48x48)\n                        canvasCtx.fillRect(0, 0, 48, 48);\n                        // clear canvas data\n                        destinationCanvas.dataset.canvasId = null;\n                    }\n                }\n                else {\n                    const destinationCoordinates = functions.extractNumbersFromId(object.id, \"right\");\n                    const sourceCoordinates = functions.extractNumbersFromId(object.data, \"left\");\n                    // copy image from given id\n                    const destinationCanvas = gameData_1.gameData.visibleRightPanelCanvas[destinationCoordinates[0]][destinationCoordinates[1]];\n                    const sourceCanvas = gameData_1.gameData.leftPanelCanvas[sourceCoordinates[0]][sourceCoordinates[1]][sourceCoordinates[2]];\n                    // !!!!! here, because value can potentially (in theory) be \"undefined\" and undefined\n                    // \n                    // check if value changed \n                    if (sourceCanvas.id != destinationCanvas.dataset.canvasId) {\n                        // copy the image\n                        const destinationCanvasCtx = destinationCanvas.getContext('2d');\n                        destinationCanvasCtx.drawImage(sourceCanvas, 0, 0);\n                        // add canvas data\n                        destinationCanvas.dataset.canvasId = sourceCanvas.id;\n                    }\n                }\n            });\n            // remove now or when some action comes in?\n            gameData_1.gameData.recentlyRedone = true;\n        }\n    },\n    /**\n     * called when delete key is clicked or function is chosen from contextmenu\n     * clears / removes selected canvas\n     */\n    delete() {\n        if (gameData_1.gameData.selectedCanvas.length != 0) {\n            // perform delete action on selected elements\n            console.log(gameData_1.gameData.selectedCanvas);\n            gameData_1.gameData.selectedCanvas.forEach(canvas => {\n                // check if value changed \n                if (canvas.dataset.canvasId != null && canvas.dataset.canvasId != undefined && canvas.dataset.canvasId != \"undefined\" && canvas.dataset.canvasId != \"null\") {\n                    // clear the canvas\n                    const canvasCtx = canvas.getContext('2d');\n                    // Set the fill color to black\n                    canvasCtx.fillStyle = 'black';\n                    // Draw a black square that fills the entire canvas (48x48)\n                    canvasCtx.fillRect(0, 0, 48, 48);\n                    // clear canvas data\n                    canvas.dataset.canvasId = null;\n                    console.log(\"hubysz ybysz canvas cleared :D\");\n                }\n            });\n            // clear selected canvas\n            gameData_1.gameData.clearSelectedCanvas();\n            functions.registerAction();\n        }\n    }\n};\nexports.functions = functions;\n\n\n//# sourceURL=webpack://9cw_generatormap/./src/funstions.ts?");

/***/ }),

/***/ "./src/game.ts":
/*!*********************!*\
  !*** ./src/game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Game = void 0;\nconst leftPanelGeneration_1 = __webpack_require__(/*! ./leftPanelGeneration */ \"./src/leftPanelGeneration.ts\");\nconst rightPanelGeneration_1 = __webpack_require__(/*! ./rightPanelGeneration */ \"./src/rightPanelGeneration.ts\");\nconst gameData_1 = __webpack_require__(/*! ./gameData */ \"./src/gameData.ts\");\n/**\n * main class of the project, after it's inicialization all other things required to run the game are started\n * @param onInitialized a function that will be called AFTER everything in constructor() has finished,\n * in our case in constructor() we initialize all DOM elements from various classes like new rightPanelGeneration, new leftPanelGeneration\n * onInitialized is a function with all listeners\n */\nclass Game {\n    constructor(onInitialized) {\n        // add yellowRectangle\n        const yellowRectangle = document.createElement(\"div\");\n        yellowRectangle.id = \"yellowRectangle\";\n        document.body.append(yellowRectangle);\n        // generate right panel\n        new rightPanelGeneration_1.rightPanelGeneration(gameData_1.gameData.rightPanelRows, gameData_1.gameData.rightPanelCols);\n        // generate 2nd right panel that is hidden (needed for copy / paste)\n        new rightPanelGeneration_1.rightPanelGeneration(gameData_1.gameData.rightPanelRows, gameData_1.gameData.rightPanelCols, true);\n        // generate left panel\n        new leftPanelGeneration_1.leftPanelGeneration(2, 16, 20);\n        // console.log(gameData.leftPanelCanvas);\n        // prepare current selected image\n        const div = document.createElement(\"div\");\n        div.id = \"bottomInfo\";\n        const p = document.createElement(\"p\");\n        p.innerHTML = \"Current element: \";\n        div.append(p);\n        // element in right bottom of page, describes which bakcground is chosen\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = 48;\n        canvas.height = 48;\n        canvas.id = \"hiddenItem\";\n        const body = document.getElementById(\"body\");\n        div.append(canvas);\n        // save dom element to variable\n        gameData_1.gameData.hiddenItem = canvas;\n        // create automat checkbox\n        const autoDiv = document.createElement(\"div\");\n        const checkBox = document.createElement(\"input\");\n        checkBox.type = \"checkbox\";\n        checkBox.id = \"automat\";\n        autoDiv.append(checkBox);\n        autoDiv.id = \"autoDiv\";\n        div.append(autoDiv);\n        div.innerHTML += \"auto\";\n        body.append(div);\n        if (typeof onInitialized === 'function') {\n            const rightPanel = document.getElementById(\"rightPanel\");\n            console.log(rightPanel);\n            onInitialized();\n        }\n        // get all required DOM elements once and save them in a variable\n        // const hiddenItem = document.getElementById(\"hiddenItem\") as HTMLCanvasElement\n        //  = hiddenItem\n    }\n}\nexports.Game = Game;\n\n\n//# sourceURL=webpack://9cw_generatormap/./src/game.ts?");

/***/ }),

/***/ "./src/gameData.ts":
/*!*************************!*\
  !*** ./src/gameData.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.gameData = void 0;\n/**\n * Default game settings.\n * @type {GameData}\n */\nconst gameData = {\n    rightPanelRows: 25,\n    rightPanelCols: 25,\n    startCanvasId: \"null\",\n    endCanvasId: \"null\",\n    selectedCanvas: [],\n    ctrlDown: false,\n    clearSelectedCanvas: function () {\n        this.selectedCanvas.forEach((canvas) => {\n            canvas.classList.remove(\"selected\");\n        });\n        this.selectedCanvas = [];\n    },\n    yellowRectangleStartY: 0,\n    yellowRectangleStartX: 0,\n    autoCheckbox: false,\n    contextMenuShown: false,\n    copiedCanvas: null,\n    pasteAction: false,\n    lastCanvas: null,\n    currentCanvas: null,\n    pasteInterval: null,\n    previouslyChangedCanvas: null,\n    cutAction: false,\n    rightPanelVisibleLog: [],\n    visibleLogIndex: -1,\n    recentlyUndone: false,\n    recentlyRedone: false,\n    copyStatus: false,\n    // \n    hiddenItem: null,\n    visibleRightPanelCanvas: [],\n    hiddenRightPanelCanvas: [],\n    leftPanelCanvas: []\n    // rightPanelHiddenLog: [],\n};\nexports.gameData = gameData;\n\n\n//# sourceURL=webpack://9cw_generatormap/./src/gameData.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst game_1 = __webpack_require__(/*! ./game */ \"./src/game.ts\");\nconst listeners_1 = __webpack_require__(/*! ./listeners */ \"./src/listeners.ts\");\n// start game\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    console.log(\"test / script is present\");\n    // generate html\n    new game_1.Game(listeners_1.listen);\n});\n\n\n//# sourceURL=webpack://9cw_generatormap/./src/index.ts?");

/***/ }),

/***/ "./src/leftPanelGeneration.ts":
/*!************************************!*\
  !*** ./src/leftPanelGeneration.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.leftPanelGeneration = void 0;\nconst funstions_1 = __webpack_require__(/*! ./funstions */ \"./src/funstions.ts\");\nconst gameData_1 = __webpack_require__(/*! ./gameData */ \"./src/gameData.ts\");\nconst { loadCurrentImage, changeBackgroundImage, selectNext } = funstions_1.functions;\n/**\n * generates DOM elements required for leftPanel,\n * sets id's and classes of canvas element's in leftPanel,\n * loads images for canvases in leftPanel\n */\nclass leftPanelGeneration {\n    constructor(blocks, columns, rows) {\n        this.blocks = blocks;\n        this.rows = rows;\n        this.columns = columns;\n        this.canvasGeneration();\n    }\n    /**\n     * main DOM generation process\n     */\n    canvasGeneration() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const leftPanel = document.createElement(\"div\");\n            leftPanel.id = \"leftPanel\";\n            let bg = { x: 0, y: 0 };\n            // let backgroundX: number = 0\n            // let backgroundY: number = 0\n            // each block\n            for (let b = 0; b < this.blocks; b++) {\n                // gameData.leftPanelCanvas[b] = []\n                // each row\n                for (let r = 0; r < this.rows; r++) {\n                    const row = document.createElement(\"div\");\n                    row.className = \"row\";\n                    // \n                    if (r == 0) {\n                        gameData_1.gameData.leftPanelCanvas[b] = [];\n                    }\n                    // each column\n                    for (let c = 0; c < this.columns; c++) {\n                        // \n                        if (c == 0) {\n                            gameData_1.gameData.leftPanelCanvas[b][r] = [];\n                        }\n                        yield this.loadImage(row, bg.x, bg.y, b, r, c);\n                        bg.x += 48;\n                    }\n                    leftPanel.append(row);\n                    bg.y += 48;\n                    bg.x -= 768;\n                }\n                bg.x += 768;\n                bg.y = 0;\n            }\n            const body = document.getElementById(\"body\");\n            body.append(leftPanel);\n        });\n    }\n    /**\n     * loads images for canvases on leftPanel\n     * adds canvases id's\n     * adds basic onclick eventlis tener\n     * @param row a parent DOM element\n     * @param backgroundX x of square start on sptite / img\n     * @param backgroundY y of square start on sptite / img\n     * @param blockNumber block of canvas element (image sprites.png is divided to 2 blocks)\n     * @param rowNumber row of canvas element\n     * @param columnNumber column of canvas element\n     * @returns\n     */\n    loadImage(row, backgroundX, backgroundY, blockNumber, rowNumber, columnNumber) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                const canvas = document.createElement(\"canvas\");\n                canvas.width = 48;\n                canvas.height = 48;\n                canvas.className = \"leftPanelItem\";\n                // add id - needed for saving / loading images\n                canvas.id = `b${blockNumber}r${rowNumber}c${columnNumber}`;\n                gameData_1.gameData.leftPanelCanvas[blockNumber][rowNumber][columnNumber] = canvas;\n                canvas.onclick = () => __awaiter(this, void 0, void 0, function* () {\n                    // save selected canvas\n                    let tmp = gameData_1.gameData.selectedCanvas;\n                    yield loadCurrentImage(backgroundX, backgroundY);\n                    changeBackgroundImage(gameData_1.gameData.selectedCanvas, canvas.id);\n                    // check if should select next\n                    selectNext(tmp);\n                    // register action (needed for undo redo)\n                    if (tmp.length != 0) {\n                        funstions_1.functions.registerAction();\n                    }\n                });\n                const ctx = canvas.getContext(\"2d\");\n                let img = new Image();\n                img.src = \"sprites.png\";\n                img.onload = function () {\n                    ctx.drawImage(this, backgroundX, backgroundY, 48, 48, 0, 0, 48, 48);\n                    row.append(canvas);\n                    resolve(\"ok\");\n                };\n            });\n        });\n    }\n}\nexports.leftPanelGeneration = leftPanelGeneration;\n\n\n//# sourceURL=webpack://9cw_generatormap/./src/leftPanelGeneration.ts?");

/***/ }),

/***/ "./src/listeners.ts":
/*!**************************!*\
  !*** ./src/listeners.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.listen = void 0;\nconst funstions_1 = __webpack_require__(/*! ./funstions */ \"./src/funstions.ts\");\nconst gameData_1 = __webpack_require__(/*! ./gameData */ \"./src/gameData.ts\");\n/**\n * adds all necessary listeners for game to work\n */\nconst listen = function () {\n    const rightPanel = document.getElementById(\"rightPanel\");\n    const yellowRectangle = document.getElementById(\"yellowRectangle\");\n    console.log(rightPanel);\n    // event listeners for draging\n    rightPanel.addEventListener(\"mousemove\", function (e) {\n        // check if we are not pasting anything at the moment\n        if (gameData_1.gameData.startCanvasId != \"null\" && gameData_1.gameData.pasteInterval == null) {\n            // draw a yellow rectangle\n            let calculatedX = e.clientX - gameData_1.gameData.yellowRectangleStartX;\n            let calculatedY = e.clientY - gameData_1.gameData.yellowRectangleStartY;\n            // width is an absolute calculated value, \n            // if calculated value is negative, we use translate from CSS\n            let translateX = \"0px\";\n            let translateY = \"0px\";\n            if (calculatedX < 0) {\n                translateX = `${calculatedX}px`;\n            }\n            if (calculatedY < 0) {\n                translateY = `${calculatedY}px`;\n            }\n            const width = `${Math.abs(calculatedX)}px`;\n            const height = `${Math.abs(calculatedY)}px`;\n            yellowRectangle.style.width = width;\n            yellowRectangle.style.height = height;\n            yellowRectangle.style.translate = `${translateX} ${translateY}`;\n            console.log(\"mousemove\");\n        }\n    });\n    document.addEventListener(\"mouseup\", function () {\n        gameData_1.gameData.endCanvasId = \"null\";\n        gameData_1.gameData.startCanvasId = \"null\";\n        // yellow rect\n        gameData_1.gameData.yellowRectangleStartX = 0;\n        gameData_1.gameData.yellowRectangleStartY = 0;\n        yellowRectangle.style.width = \"0px\";\n        yellowRectangle.style.height = \"0px\";\n    });\n    rightPanel.addEventListener(\"mousedown\", function (e) {\n        // check if we are not pasting anything at the moment\n        if (gameData_1.gameData.pasteInterval == null) {\n            // yellow rect drag\n            yellowRectangle.style.left = ` ${e.clientX}px`;\n            yellowRectangle.style.top = ` ${e.clientY}px`;\n            gameData_1.gameData.yellowRectangleStartX = e.clientX;\n            gameData_1.gameData.yellowRectangleStartY = e.clientY;\n        }\n    });\n    window.addEventListener(\"DOMContentLoaded\", function () {\n        console.log(\"DOMContentLoaded\");\n        // add dialog for contextmenu\n        const dialog = document.createElement(\"dialog\");\n        dialog.id = \"constextMenu\";\n        const contextOptions = [\n            {\n                name: \"save\",\n                shortcut: \"ctrl + S\"\n            },\n            {\n                name: \"load\",\n                shortcut: \"ctrl + L\"\n            },\n            {\n                name: \"copy\",\n                shortcut: \"ctrl + C\"\n            },\n            {\n                name: \"paste\",\n                shortcut: \"ctrl + V\"\n            },\n            {\n                name: \"cut\",\n                shortcut: \"ctrl + X\"\n            },\n            {\n                name: \"undo\",\n                shortcut: \"ctrl + Z\"\n            },\n            {\n                name: \"redo\",\n                shortcut: \"ctrl + Y\"\n            },\n            {\n                name: \"delete\",\n                shortcut: \"delete\"\n            }\n        ];\n        // use a document fragment to minimise the use of DOM\n        const fragment = document.createDocumentFragment();\n        contextOptions.forEach(element => {\n            const div = document.createElement(\"div\");\n            const pLeft = document.createElement(\"p\");\n            pLeft.innerHTML = element.name;\n            pLeft.classList.add(\"pLeft\");\n            div.append(pLeft);\n            const pRight = document.createElement(\"p\");\n            pRight.innerHTML = element.shortcut;\n            pRight.classList.add(\"pRight\");\n            div.append(pRight);\n            // Assign function based on name\n            if (element.name === \"save\") {\n                div.addEventListener(\"click\", funstions_1.functions.save);\n            }\n            else if (element.name === \"load\") {\n                div.addEventListener(\"click\", funstions_1.functions.selectAFileFunc);\n            }\n            else if (element.name == \"copy\") {\n                div.addEventListener(\"click\", () => {\n                    funstions_1.functions.copy();\n                });\n            }\n            else if (element.name == \"paste\") {\n                div.addEventListener(\"click\", funstions_1.functions.paste);\n            }\n            else if (element.name == \"cut\") {\n                div.addEventListener(\"click\", funstions_1.functions.cut);\n            }\n            else if (element.name == \"undo\") {\n                div.addEventListener(\"click\", funstions_1.functions.undo);\n            }\n            else if (element.name == \"redo\") {\n                div.addEventListener(\"click\", funstions_1.functions.redo);\n            }\n            else if (element.name == \"delete\") {\n                div.addEventListener(\"click\", funstions_1.functions.delete);\n            }\n            // Add common click event\n            div.addEventListener(\"click\", funstions_1.functions.contextMenuManager);\n            // Append the div to the fragment instead of the dialog directly\n            fragment.append(div);\n        });\n        // Append the fragment to the dialog in one operation\n        dialog.append(fragment);\n        document.body.append(dialog);\n        // create file select (for loading files)\n        funstions_1.functions.createFileSelect();\n        // when both right panels are generated, register first action (as all is empty)\n        funstions_1.functions.registerAction();\n    });\n    // check system\n    let osName = \"Unknown OS\";\n    if (navigator.userAgent.indexOf(\"Win\") != -1)\n        osName =\n            \"Windows OS\";\n    if (navigator.userAgent.indexOf(\"Mac\") != -1)\n        osName =\n            \"Macintosh\";\n    if (navigator.userAgent.indexOf(\"Linux\") != -1)\n        osName =\n            \"Linux OS\";\n    if (navigator.userAgent.indexOf(\"Android\") != -1)\n        osName =\n            \"Android OS\";\n    if (navigator.userAgent.indexOf(\"like Mac\") != -1)\n        osName =\n            \"iOS\";\n    console.log(osName);\n    // context menu\n    window.addEventListener(\"contextmenu\", function (e) {\n        funstions_1.functions.contextMenuManager(e);\n    });\n    // event listeners for ctrl\n    window.addEventListener(\"keydown\", function (e) {\n        console.log(e.key);\n        // manage and check if ctrl key is pressed\n        if (e.key == \"Control\" && osName != \"Macintosh\") {\n            gameData_1.gameData.ctrlDown = true;\n        }\n        if (e.key == \"Meta\" && osName == \"Macintosh\") {\n            gameData_1.gameData.ctrlDown = true;\n        }\n        // remove default actions like ctrl + s\n        if (e.ctrlKey) {\n            e.preventDefault;\n        }\n        if (e.metaKey) {\n            e.preventDefault;\n        }\n        // save (ctrl + L)\n        if (e.key.toUpperCase() == \"S\" && gameData_1.gameData.ctrlDown) {\n            // save to file\n            funstions_1.functions.save();\n        }\n        // load (crtl + L)\n        if (e.key.toUpperCase() == \"L\" && gameData_1.gameData.ctrlDown) {\n            funstions_1.functions.selectAFileFunc();\n        }\n        // copy (ctrl + C)\n        if (e.key.toUpperCase() == \"C\" && gameData_1.gameData.ctrlDown) {\n            funstions_1.functions.copy();\n        }\n        // paste\n        if (e.key.toUpperCase() == \"V\" && gameData_1.gameData.ctrlDown) {\n            funstions_1.functions.paste();\n        }\n        // cut \n        if (e.key.toUpperCase() == \"X\" && gameData_1.gameData.ctrlDown) {\n            funstions_1.functions.cut();\n        }\n        // undo\n        if (e.key.toUpperCase() == \"Z\" && gameData_1.gameData.ctrlDown) {\n            funstions_1.functions.undo();\n        }\n        // redo\n        if (e.key.toUpperCase() == \"Y\" && gameData_1.gameData.ctrlDown) {\n            funstions_1.functions.redo();\n        }\n        // delete\n        if (e.key == \"Delete\") {\n            funstions_1.functions.delete();\n        }\n    });\n    document.addEventListener(\"keyup\", function (e) {\n        if (e.key == \"Control\" && osName != \"Macintosh\") {\n            e.preventDefault();\n            gameData_1.gameData.ctrlDown = false;\n        }\n        if (e.key == \"Meta\" && osName == \"Macintosh\") {\n            gameData_1.gameData.ctrlDown = false;\n        }\n    });\n    // auto checkbox\n    const automat = document.getElementById(\"automat\");\n    automat.addEventListener(\"input\", function () {\n        if (this.checked) {\n            gameData_1.gameData.autoCheckbox = true;\n        }\n        else {\n            gameData_1.gameData.autoCheckbox = false;\n        }\n    });\n};\nexports.listen = listen;\n\n\n//# sourceURL=webpack://9cw_generatormap/./src/listeners.ts?");

/***/ }),

/***/ "./src/rightPanelGeneration.ts":
/*!*************************************!*\
  !*** ./src/rightPanelGeneration.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rightPanelGeneration = void 0;\nconst funstions_1 = __webpack_require__(/*! ./funstions */ \"./src/funstions.ts\");\nconst { selectCanvas } = funstions_1.functions;\nconst gameData_1 = __webpack_require__(/*! ./gameData */ \"./src/gameData.ts\");\n/**\n * generates rightPanel\n * rows X columns = amount of canvas elements in DOM in rightPanel\n * @param rows number of rows\n * @param columns number of columns\n * @param hidden determine if rightPanel should be hidden (not visible for user, needed for copy / cut / paste actions)\n */\nclass rightPanelGeneration {\n    constructor(rows, columns, hidden = false) {\n        this.columns = columns;\n        this.rows = rows;\n        this.hidden = hidden;\n        this.domGeneration();\n    }\n    domGeneration() {\n        const rightPanel = document.createElement(\"div\");\n        if (!this.hidden) {\n            rightPanel.id = \"rightPanel\";\n        }\n        else {\n            rightPanel.id = \"rightPanelHidden\";\n        }\n        for (let r = 0; r < this.rows; r++) {\n            const row = document.createElement(\"div\");\n            row.className = \"row\";\n            for (let c = 0; c < this.columns; c++) {\n                const canvas = document.createElement(\"canvas\");\n                canvas.width = 48;\n                canvas.height = 48;\n                canvas.className = \"rightPanelItem\";\n                if (!this.hidden) {\n                    canvas.id = `r${r}c${c}`;\n                    canvas.dataset.canvasId = null;\n                    // prepare a new array\n                    if (c == 0) {\n                        gameData_1.gameData.visibleRightPanelCanvas[r] = [];\n                    }\n                    // save canvas element to a variable\n                    gameData_1.gameData.visibleRightPanelCanvas[r][c] = canvas;\n                    // base click\n                    canvas.onclick = function () {\n                        // check if we should clear selected canvas\n                        if (gameData_1.gameData.ctrlDown == false) {\n                            gameData_1.gameData.clearSelectedCanvas();\n                            // select new\n                            gameData_1.gameData.selectedCanvas = [canvas];\n                        }\n                        else {\n                            gameData_1.gameData.selectedCanvas.push(canvas);\n                        }\n                        // clear selected elements after paste with cut\n                        if (gameData_1.gameData.cutAction) {\n                            // check if canvas that were pasted arent in copied canvas\n                            funstions_1.functions.pastedInCopied();\n                            funstions_1.functions.finishCut();\n                            gameData_1.gameData.cutAction = false;\n                        }\n                        // check if we should stop interval from paste / confirm the paste action\n                        if (gameData_1.gameData.pasteInterval != null) {\n                            clearInterval(gameData_1.gameData.pasteInterval);\n                            gameData_1.gameData.pasteInterval = null;\n                            // accept previous changes\n                            gameData_1.gameData.previouslyChangedCanvas = null;\n                            // remove the borders from canvas that were selected\n                            gameData_1.gameData.copiedCanvas.forEach(canvas => {\n                                if (canvas != null) {\n                                    funstions_1.functions.removeCSSFromSelected(canvas);\n                                }\n                            });\n                            // finish copy action\n                            gameData_1.gameData.copyStatus = false;\n                            // \n                            funstions_1.functions.registerAction();\n                        }\n                        else {\n                            canvas.classList.add(\"selected\");\n                        }\n                    };\n                    // drag\n                    canvas.onmousedown = function () {\n                        if (gameData_1.gameData.pasteInterval == null) {\n                            gameData_1.gameData.startCanvasId = canvas.id;\n                        }\n                    };\n                    canvas.addEventListener(\"mousemove\", function () {\n                        if (gameData_1.gameData.startCanvasId != \"null\") {\n                            gameData_1.gameData.endCanvasId = this.id;\n                            selectCanvas();\n                        }\n                    });\n                    // needed for paste\n                    canvas.addEventListener(\"mouseover\", function () {\n                        if (!gameData_1.gameData.pasteAction) {\n                            gameData_1.gameData.currentCanvas = this;\n                        }\n                    });\n                }\n                else {\n                    canvas.id = `hr${r}c${c}`;\n                    canvas.dataset.canvasId = null;\n                    // prepare a new array\n                    if (c == 0) {\n                        gameData_1.gameData.hiddenRightPanelCanvas[r] = [];\n                    }\n                    // save canvas element to a variable\n                    gameData_1.gameData.hiddenRightPanelCanvas[r][c] = canvas;\n                    // draw a back square by default\n                    // \n                    // \n                    const canvasCtx = canvas.getContext('2d');\n                    // Set the fill color to black\n                    canvasCtx.fillStyle = 'black';\n                    // Draw a black square that fills the entire canvas (48x48)\n                    canvasCtx.fillRect(0, 0, 48, 48);\n                }\n                row.append(canvas);\n            }\n            rightPanel.append(row);\n        }\n        const body = document.getElementById(\"body\");\n        body.append(rightPanel);\n    }\n}\nexports.rightPanelGeneration = rightPanelGeneration;\n\n\n//# sourceURL=webpack://9cw_generatormap/./src/rightPanelGeneration.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;