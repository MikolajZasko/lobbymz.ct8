/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/gameData.ts":
/*!*************************!*\
  !*** ./src/gameData.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.gameData = void 0;\n// interface twoDimentionalArray extends Array<number> {\n//     [index: number][index: number]: number\n// }\nconst gameData = {\n    canvas: null,\n    canvasContext: null,\n    // size of your map generator\n    canvasRows: 25,\n    canvasCollumns: 25,\n    // logical wiev of our ghost walking game,\n    // 0 - no path\n    // 1 - path\n    // 2 - ghost currently on\n    gameArray: [],\n    // find first path / spawn point\n    firstPathBool: true,\n    firstPathCoords: null,\n    // ghosts:\n    ghostArray: [],\n    ghostsNumber: 5,\n    interval: null,\n    loadedImage: null\n};\nexports.gameData = gameData;\n// create gameArray\nfor (let r = 0; r < gameData.canvasRows; r++) {\n    gameData.gameArray[r] = [];\n    for (let c = 0; c < gameData.canvasCollumns; c++) {\n        gameData.gameArray[r][c] = 0;\n        console.log(\"asass\");\n    }\n}\n// create set amount of ghosts\nfor (let i = 0; i < gameData.ghostsNumber; i++) {\n    gameData.ghostArray[i] = {\n        direction: null,\n        row: null,\n        coll: null\n    };\n}\n\n\n//# sourceURL=webpack://ghosts/./src/gameData.ts?");

/***/ }),

/***/ "./src/ghostLogic.ts":
/*!***************************!*\
  !*** ./src/ghostLogic.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ghostLogic = void 0;\nconst gameData_1 = __webpack_require__(/*! ./gameData */ \"./src/gameData.ts\");\nconst ghostLogic = {\n    spawnGhosts() {\n        gameData_1.gameData.ghostArray.forEach(ghost => {\n            // console.log(ghost.row);\n            console.log(ghost);\n            // set spawn point\n            ghost.row = gameData_1.gameData.firstPathCoords.row;\n            ghost.coll = gameData_1.gameData.firstPathCoords.coll;\n            // x coordinate on spritesheet.png\n            const sx = 0;\n            // Y coordinate on spritesheet.png\n            const sy = 12 * 48;\n            // width of copied part\n            const sWidth = 48 * 2;\n            // height of copied part\n            const sHeight = 48 * 2;\n            // Define where to draw the part on the canvas\n            const dx = ghost.row * 48; // x coordinate on the canvas\n            const dy = ghost.coll * 48; // y coordinate on the canvas\n            const dWidth = 48; // width of the image on the canvas\n            const dHeight = 48; // height of the image on the canvas\n            // draw on map\n            gameData_1.gameData.canvasContext.drawImage(gameData_1.gameData.loadedImage, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n            // get the first direction\n            ghostLogic.getDirections(ghost);\n        });\n        // start walking\n        gameData_1.gameData.interval = setInterval(ghostLogic.tick, 500);\n    },\n    getDirections(ghost) {\n        // check if we have direction or is it the first time\n        if (ghost.direction == null || (ghost.direction != null && ghostLogic.onIntersection(ghost, false))) {\n            const possibleDirections = ghostLogic.onIntersection(ghost, true);\n            if (Array.isArray(possibleDirections)) {\n                const randomId = Math.floor(Math.random() * (possibleDirections.length - 0)) + 0;\n                // const randomId = Math.round(Math.random() * possibleDirections.length);\n                // get and set the direction\n                ghost.direction = possibleDirections[randomId];\n            }\n        }\n        else {\n            // do nothing, direction stays the same\n        }\n    },\n    onIntersection(ghost, returnRes) {\n        const currentX = ghost.coll;\n        const currentY = ghost.row;\n        let turns = [];\n        // check up\n        if (gameData_1.gameData.gameArray[currentX][currentY - 1] == 1) {\n            turns.push('up');\n        }\n        // check right\n        if (gameData_1.gameData.gameArray[currentX + 1][currentY] == 1) {\n            turns.push('right');\n        }\n        // check down\n        if (gameData_1.gameData.gameArray[currentX][currentY + 1] == 1) {\n            turns.push('down');\n        }\n        // check left\n        if (gameData_1.gameData.gameArray[currentX - 1][currentY] == 1) {\n            turns.push('left');\n        }\n        if (returnRes) {\n            return turns;\n        }\n        else {\n            // check if intersection\n            if (turns.length > 2) {\n                return true;\n            }\n            // check if it is a straight line\n            else if (turns.includes('right') && turns.includes(\"left\")) {\n                return false;\n            }\n            else if (turns.includes('up') && turns.includes('down')) {\n                return false;\n            }\n            // it has to be a turn\n            else {\n                return true;\n            }\n        }\n    },\n    tick() {\n        // for every existant ghost\n        gameData_1.gameData.ghostArray.forEach(ghost => {\n            // check if we need a new direction and set it if necessary\n            ghostLogic.getDirections(ghost);\n            // remove on canvas\n            // x coordinate on spritesheet.png\n            let sx = 48 * 16;\n            // Y coordinate on spritesheet.png\n            let sy = 0;\n            // width of copied part\n            let sWidth = 48;\n            // height of copied part\n            let sHeight = 48;\n            // Define where to draw the part on the canvas\n            let dx = ghost.row * 48; // x coordinate on the canvas\n            let dy = ghost.coll * 48; // y coordinate on the canvas\n            let dWidth = 48; // width of the image on the canvas\n            let dHeight = 48; // height of the image on the canvas\n            // draw on map\n            gameData_1.gameData.canvasContext.drawImage(gameData_1.gameData.loadedImage, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n            // perform logical move\n            if (ghost.direction == \"up\") {\n                ghost.row -= 1;\n            }\n            else if (ghost.direction == \"right\") {\n                ghost.coll += 1;\n            }\n            else if (ghost.direction == \"down\") {\n                ghost.row += 1;\n            }\n            else if (ghost.direction == \"left\") {\n                ghost.coll -= 1;\n            }\n            // perform graphical move\n            // x coordinate on spritesheet.png\n            sx = 0;\n            // Y coordinate on spritesheet.png\n            sy = 12 * 48;\n            // width of copied part\n            sWidth = 48 * 2;\n            // height of copied part\n            sHeight = 48 * 2;\n            // Define where to draw the part on the canvas\n            dx = ghost.row * 48; // x coordinate on the canvas\n            dy = ghost.coll * 48; // y coordinate on the canvas\n            dWidth = 48; // width of the image on the canvas\n            dHeight = 48; // height of the image on the canvas\n            // draw on map\n            gameData_1.gameData.canvasContext.drawImage(gameData_1.gameData.loadedImage, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n        });\n    }\n};\nexports.ghostLogic = ghostLogic;\n\n\n//# sourceURL=webpack://ghosts/./src/ghostLogic.ts?");

/***/ }),

/***/ "./src/giantCanvas.ts":
/*!****************************!*\
  !*** ./src/giantCanvas.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.giantCanvas = void 0;\nconst gameData_1 = __webpack_require__(/*! ./gameData */ \"./src/gameData.ts\");\nclass giantCanvas {\n    constructor(rows, columns) {\n        this.rows = rows;\n        this.columns = columns;\n    }\n    createHTML() {\n        console.log(\"createHTML\");\n        // calculate height / width\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = this.columns * 48;\n        canvas.height = this.rows * 48;\n        canvas.id = \"bigCanvas\";\n        document.body.append(canvas);\n        // add to gameData\n        gameData_1.gameData.canvas = canvas;\n        // add context ctx to game data\n        gameData_1.gameData.canvasContext = canvas.getContext(\"2d\");\n        // for (let c = 0; c < this.columns; c++) {\n        //     for (let r = 0; r < this.rows; r++) {\n        //     }\n        // }\n    }\n}\nexports.giantCanvas = giantCanvas;\n\n\n//# sourceURL=webpack://ghosts/./src/giantCanvas.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst loadFile_1 = __webpack_require__(/*! ./loadFile */ \"./src/loadFile.ts\");\nconst giantCanvas_1 = __webpack_require__(/*! ./giantCanvas */ \"./src/giantCanvas.ts\");\nconst gameData_1 = __webpack_require__(/*! ./gameData */ \"./src/gameData.ts\");\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    console.log(\"sas\");\n    // create big ass canvas\n    const giantCanvasClass = new giantCanvas_1.giantCanvas(gameData_1.gameData.canvasRows, gameData_1.gameData.canvasCollumns);\n    giantCanvasClass.createHTML();\n    // create file select (for loading files)\n    loadFile_1.loadFileFunctions.createFileSelect();\n});\n\n\n//# sourceURL=webpack://ghosts/./src/index.ts?");

/***/ }),

/***/ "./src/loadFile.ts":
/*!*************************!*\
  !*** ./src/loadFile.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.loadFileFunctions = void 0;\nconst gameData_1 = __webpack_require__(/*! ./gameData */ \"./src/gameData.ts\");\nconst ghostLogic_1 = __webpack_require__(/*! ./ghostLogic */ \"./src/ghostLogic.ts\");\nconst loadFileFunctions = {\n    selectAFileFunc() {\n        console.log(\"fileSelect\");\n        // prompt user for a file\n        const fileSelect = document.getElementById(\"fileSelect\");\n        // console.log(\"fileSelect here : \", fileSelect);\n        fileSelect.click();\n    },\n    readFile(file) {\n        const reader = new FileReader();\n        reader.readAsText(file);\n        reader.onload = function () {\n            // restore game state from data\n            loadFileFunctions.restoreData(reader.result);\n        };\n    },\n    restoreData(rederRes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // here we try to get data, if json is invalid throw an error as an alert()\n            let jsonRes;\n            try {\n                jsonRes = JSON.parse(rederRes);\n            }\n            catch (error) {\n                // Handle the error gracefully\n                console.error(\"Error parsing JSON:\", error);\n                jsonRes = false;\n            }\n            if (jsonRes) {\n                console.log(\"we can restore\");\n                if (jsonRes.length > 0) {\n                    // get unique images to load one by one\n                    let uniqueImagesFound = [];\n                    let canvasByImages = {};\n                    jsonRes.forEach((element) => {\n                        let leftPositionId = element.leftPositionId;\n                        let rightPositionId = element.rightPositionId;\n                        if (!uniqueImagesFound.includes(element.leftPositionId)) {\n                            // add to unique\n                            uniqueImagesFound.push(element.leftPositionId);\n                            // add new obj to canvasByImages + value\n                            canvasByImages[leftPositionId] = [rightPositionId];\n                        }\n                        else {\n                            // add rightPositionId to existing canvasToLoad\n                            canvasByImages[leftPositionId].push(rightPositionId);\n                        }\n                    });\n                    // clear background\n                    const context = gameData_1.gameData.canvasContext;\n                    context.fillStyle = 'black';\n                    context.fillRect(0, 0, gameData_1.gameData.canvasRows * 48, gameData_1.gameData.canvasCollumns * 48);\n                    // load image\n                    const image = new Image();\n                    image.src = \"sprites.png\";\n                    image.onload = () => {\n                        gameData_1.gameData.loadedImage = image;\n                        // start loading images and placing them on board\n                        for (let i = 0; i < uniqueImagesFound.length; i++) {\n                            const leftCanvasID = uniqueImagesFound[i];\n                            // extract coordinates from id\n                            const LCanvasCoordinates = loadFileFunctions.extractNumbersFromId(leftCanvasID, \"left\");\n                            // find the right spritesheet image\n                            const canvasB = LCanvasCoordinates[0]; // block 1 or 2\n                            const canvasR = LCanvasCoordinates[1]; // row\n                            const canvasC = LCanvasCoordinates[2]; // collumn\n                            // x coordinate on spritesheet.png\n                            let sx;\n                            if (canvasB == 0) {\n                                sx = canvasC * 48;\n                            }\n                            else {\n                                // add 1 block\n                                sx = canvasC * 48 + 16 * 48;\n                            }\n                            // console.log(sx);\n                            // Y coordinate on spritesheet.png\n                            const sy = canvasR * 48;\n                            // width of copied part\n                            const sWidth = 48;\n                            // height of copied part\n                            const sHeight = 48;\n                            // check if this is the path that ghosts can move on\n                            let path = false;\n                            if (canvasB == 1 && canvasR == 0 && canvasC == 0) {\n                                // console.log(\"path\");\n                                path = true;\n                            }\n                            // // // copy image\n                            // // const leftCanvasDOM = gameData.leftPanelCanvas[LCanvasCoordinates[0]][LCanvasCoordinates[1]][LCanvasCoordinates[2]] as HTMLCanvasElement\n                            const rightCanvasArray = canvasByImages[leftCanvasID];\n                            for (let n = 0; n < rightCanvasArray.length; n++) {\n                                const rightCanvasID = rightCanvasArray[n];\n                                // extract coordinates from id\n                                const RCanvasCoordinates = loadFileFunctions.extractNumbersFromId(rightCanvasID, \"right\");\n                                // // copy / draw loaded image\n                                // console.log(RCanvasCoordinates);\n                                // Define where to draw the part on the canvas\n                                const dx = RCanvasCoordinates[1] * 48; // x coordinate on the canvas\n                                const dy = RCanvasCoordinates[0] * 48; // y coordinate on the canvas\n                                // console.log(dx);\n                                const dWidth = sWidth; // width of the image on the canvas\n                                const dHeight = sHeight; // height of the image on the canvas\n                                // Draw the image part on the canvas\n                                // context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n                                context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n                                if (path) {\n                                    // update that this part is a path\n                                    gameData_1.gameData.gameArray[RCanvasCoordinates[0]][RCanvasCoordinates[1]] = 1;\n                                    if (gameData_1.gameData.firstPathBool) {\n                                        gameData_1.gameData.firstPathCoords = {\n                                            row: RCanvasCoordinates[0],\n                                            coll: RCanvasCoordinates[1]\n                                        };\n                                        gameData_1.gameData.firstPathBool = false;\n                                    }\n                                }\n                            }\n                            if (i == uniqueImagesFound.length - 1) {\n                                // last\n                                // spawn ghosts\n                                ghostLogic_1.ghostLogic.spawnGhosts();\n                            }\n                        }\n                    };\n                    jsonRes = null;\n                }\n                else {\n                    alert(\"empty json / no array\");\n                }\n            }\n            else {\n                alert(\"damaged / invalid json file\");\n            }\n        });\n    },\n    createFileSelect() {\n        // Create an input element\n        const fileSelect = document.createElement('input');\n        fileSelect.type = 'file';\n        // fileSelect.value = \"load\"\n        fileSelect.accept = \"application/json\";\n        fileSelect.id = \"fileSelect\";\n        // Add an event listener to handle the file selection\n        fileSelect.addEventListener('input', (event) => {\n            const target = event.target;\n            const files = target.files;\n            if (files && files.length > 0) {\n                const selectedFile = files[0];\n                console.log('File selected:', selectedFile);\n                // Handle the selected file (e.g., read it, upload it, etc.)\n                this.readFile(selectedFile);\n            }\n            // clear the input velue so it triggers every time you upload ANY file (even the same one)\n            target.value = \"\";\n        });\n        const body = document.getElementById(\"body\");\n        body.append(fileSelect);\n    },\n    extractNumbersFromId(id, side) {\n        if (side == \"right\") {\n            // take just the numbers from id\n            let canvasId = id.split(\"c\");\n            let canvasR = parseInt(canvasId[0].slice(1));\n            let canvasC = parseInt(canvasId[1]);\n            return [canvasR, canvasC];\n        }\n        else {\n            // take just the numbers from id\n            let canvasArr1 = id.split(\"c\");\n            let canvasArr2 = canvasArr1[0].split(\"r\");\n            let canvasC = parseInt(canvasArr1[1]);\n            let canvasR = parseInt(canvasArr2[1]);\n            let canvasB = parseInt(canvasArr2[0].slice(1));\n            return [canvasB, canvasR, canvasC];\n        }\n    },\n};\nexports.loadFileFunctions = loadFileFunctions;\n\n\n//# sourceURL=webpack://ghosts/./src/loadFile.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;